<!doctype html>
<html lang="en">
<head>
<title>Sub Bottom Cross Section</title>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
<style>
    body { margin: 0; overflow: hidden; }
</style>
</head>

<body>
<div id="webgl"></div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/0.149.0/three.min.js"></script>
<script src="http://turban.github.io/webgl-terrain/lib/TrackballControls.js"></script> 
<script src="https://cdnjs.cloudflare.com/ajax/libs/proj4js/2.8.1/proj4.js"></script>
<script src="../input data/testerr2.js"></script> 

<script>
//this is a tool to convert btwn projections
//it is not needed for my fake sample dataset
//only needed when using real coordinates
//so that you can go from lat long degrees into utm meters (then plot using meters in 3js)
var utm = "+proj=utm +zone=18U";
var wgs84 = "+proj=longlat +ellps=WGS84 +datum=WGS84 +no_defs";
const transformer = proj4(wgs84,utm);
var convert1;

//setting up bare 3js scene
    var width  = window.innerWidth;
    var height = window.innerHeight;
    var scene = new THREE.Scene();
    scene.add(new THREE.AmbientLight(0xeeeeee));
	scene.background = new THREE.Color( 0x00ffff );

//i will eventually modify this part so that it auto-centers on the middle coordinate of the dataset
  var camera = new THREE.PerspectiveCamera(45, width / height, 0.1, 1000);
  camera.position.set(0, -15, 10);
  var renderer = new THREE.WebGLRenderer();
  renderer.setSize(width, height);

//defining some things for later
var data = stripmap.coords;
var numxpts = (data.length)/4;
var centery = data[2*(numxpts)-1];
var centerx = data[2*(numxpts)-2];
var centerz = data[2*(numxpts)];
var segments = Math.sqrt(numxpts);
//multiplying number of segments by 4 because we are making each point into a square pixel
var plotsegments = (segments-1);
var topo = new THREE.PlaneGeometry(60, 60, plotsegments, plotsegments)
//.toNonIndexed();
var position = topo.attributes.position;
const colors = [];
const pos = [];
const color = new THREE.Color();
  
 
 //this is the main part
 //it loops through the number of xyz points that are in the dataset
 //then for each one, it uses those coordinates to replace the xyz coordinates of the plane's vertex
 //the final value in the row (the intensity) decides what shade to plot the pixel
        for (var i = 0, l = (numxpts); i < l; i++) {
			if (isNaN(data[i])) {
//if NaN value detected, replace all three position coordinates for the vertex in question with NaN
			pos.push(NaN, NaN, NaN);
			}
			else {
//define what the current xyz values are for the point
			var currx = position.array[3*(i)];
			var currz = position.array[3*(i)+1];
			var curry = position.array[3*(i)+2];
//define the new xyz values, taken from the input data
			var newx = (data[4*i]);
			var newy = (data[4*i+1]);
			var newz = (centerz-data[4*i+2]);
			var intens = ((data[4*(i)+3]));
//put the new colours into the plane
		    color.setHSL(0.5, 1, (0.5-(intens)/100));
//push out to the colour array 4 times (for each pixel corner)
    colors.push(color.r, color.g, color.b);
//    colors.push(color.r, color.g, color.b);
//    colors.push(color.r, color.g, color.b);
//    colors.push(color.r, color.g, color.b);
//do the same with the position values
//the y & z values are flipped because we have to rotate the plane in space later
	pos.push(newx, newz, newy);
//	pos.push(newx, newz-1, newy);
//	pos.push(newx, newz-1, newy-1);
//	pos.push(newx, newz, newy-1);
//i just subtracted 1 from the y and z values to make a square easily so i could visualize where the corners are joining up to
	}
}

//push out all of our modifications to the plane
topo.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
topo.setAttribute('position', new THREE.Float32BufferAttribute(pos, 3));

//define mesh material 
        var material = new THREE.MeshBasicMaterial({
//      map: THREE.ImageUtils.loadTexture(wmsUrl),
//		color: 0xffffff,
		vertexColors: true,
		wireframe: false
        });

//add the object to our scene
        var plane = new THREE.Mesh(topo, material);
        scene.add(plane);
		
//plane.rotateX(90*(Math.PI)/180);
//plane.rotateY(180*(Math.PI)/180);


//the rest is necessary for 3js to function
    var controls = new THREE.TrackballControls(camera); 
    document.getElementById('webgl').appendChild(renderer.domElement);
    render();

    function render() {
        controls.update();    
        requestAnimationFrame(render);
        renderer.render(scene, camera);
    }
</script>
</body>
</html>
