<!doctype html>
<html lang="en">
<head>
<title>cross section</title>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
<style>
    body { margin: 0; overflow: hidden; }
</style>
</head>
<body>
<div id="webgl"></div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/0.149.0/three.min.js"></script>
<script src="http://turban.github.io/webgl-terrain/lib/TrackballControls.js"></script> 
<script src="http://turban.github.io/webgl-terrain/lib/WcsTerrainLoader.js"></script> 
<script src="http://turban.github.io/webgl-terrain/wxs/topo2.layers.js"></script> 
<script src="https://cdnjs.cloudflare.com/ajax/libs/proj4js/2.8.1/proj4.js"></script>
<script src="../input data/testerr2.js"></script> 
<script>
var subbdata = stripmap;
var numofpixels = subbdata.coords.length/4;
var ysegments = 339;
var xsegments = numofpixels/ysegments;
var test;
//var xsegments = Math.sqrt(numofpixels);
//var ysegments = xsegments/10;

var utm = "+proj=utm +zone=18U";
var wgs84 = "+proj=longlat +ellps=WGS84 +datum=WGS84 +no_defs";
const transformer = proj4(wgs84,utm);

    var width  = window.innerWidth;
    var height = window.innerHeight;
		
    var scene = new THREE.Scene();
    scene.add(new THREE.AmbientLight(0xeeeeee));

    var camera = new THREE.PerspectiveCamera(45, width / height, 0.1, 1000);
    camera.position.set(0, -ysegments, ysegments);

    var renderer = new THREE.WebGLRenderer();
    renderer.setSize(width, height);


var drape = new THREE.PlaneGeometry(1, xsegments/ysegments, ysegments, xsegments)
//.toNonIndexed();
var convert1;

  const colors = [];
  const color = new THREE.Color();
  var position2 = drape.attributes.position;

  for (let i = 0; i < numofpixels; i ++) {
   intens = subbdata.coords[i*4+3];
   latraw = subbdata.coords[i*4];
   lonraw = subbdata.coords[i*4+1];
   lat = ((subbdata.coords[i*4])-55)/1000;
   lon = ((subbdata.coords[i*4+1])+66)/1000;
   posz = (50-(subbdata.coords[i*4+2]));
   lonround = parseFloat(Math.round((lonraw)*1000)/1000);
   latround = parseFloat(Math.round((latraw)*1000)/1000);
lontest = Number.parseFloat(lonround).toFixed(3);
lattest = Number.parseFloat(latround).toFixed(3);

test = [lonround, latround];
convert1 = transformer.forward(test);
//console.log(convert1[0], convert1[1]);

			if (isNaN(intens)) {
//			color.set(0x00ff00);
    color.setHSL(0, 0, intens/80);
    colors.push(color.r, color.g, color.b);
    colors.push(color.r, color.g, color.b);
    colors.push(color.r, color.g, color.b);
    colors.push(color.r, color.g, color.b);
    colors.push(color.r, color.g, color.b);
    colors.push(color.r, color.g, color.b);
//	position2.array[3*(i)+2] = posy;
//	position2.array[3*(i)+1] = posx;
			}
			else {
    color.setHSL(0, 0, intens/61);
//    color.setHSL(0, 0, 100);
//push the same colour out 6 times so that it colours all 6 vertices that form one pixel (square bisected by line into 2 triangles)
//later remember to deal with the moving sampling window
//you can handle this by making an if statement that colours in a transparent pixel if the intensity is NaN
    colors.push(color.r, color.g, color.b);
    colors.push(color.r, color.g, color.b);
    colors.push(color.r, color.g, color.b);
    colors.push(color.r, color.g, color.b);
    colors.push(color.r, color.g, color.b);
    colors.push(color.r, color.g, color.b);
//	alert(position2.array[3*(i)]) ;
//= -15, +1 is 30
	position2.array[3*(i)] = (convert1[1]-6130300);
	position2.array[3*(i)+1] = (convert1[0]-313883.5);
	position2.array[3*(i)+2] = posz;
	position2.array[3*(i)*2] = (convert1[1]-6130300.1);
	position2.array[(3*(i)+1)*2] = (convert1[0]-313883.5);
	position2.array[(3*(i)+2)*2] = posz;
	position2.array[3*(i)*3] = (convert1[1]-6130300);
	position2.array[(3*(i)+1)*3] = (convert1[0]-313883.5);
	position2.array[(3*(i)+2)*3] = posz+0.1;
	position2.array[3*(i)*4] = (convert1[1]-6130300.1);
	position2.array[(3*(i)+1)*4] = (convert1[0]-313883.5);
	position2.array[(3*(i)+2)*4] = posz+0.1;

//	console.log(posz);

			}
  }
position2.needsUpdate = true;
drape.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));

//create a material for our mesh using the colours generated above
  const drapecolors = new THREE.MeshBasicMaterial({
    vertexColors: true,
    transparent: false,
    wireframe: false,
  });

  const crosssect = new THREE.Mesh(drape, drapecolors);
  scene.add(crosssect);
  crosssect.material.side = THREE.DoubleSide;
crosssect.rotateX(90*(Math.PI)/180);
crosssect.rotateY(180*(Math.PI)/180);
crosssect.rotateZ(270*(Math.PI)/180);



    var controls = new THREE.TrackballControls(camera); 
    document.getElementById('webgl').appendChild(renderer.domElement);
    render();

    function render() {
        controls.update();    
        requestAnimationFrame(render);
        renderer.render(scene, camera);
    }

</script>
</body>
</html>
